// -*- C++ -*-
//----------------------------------------------------------------------------
// Matrix Product Toolkit http://physics.uq.edu.au/people/ianmcc/mptoolkit/
//
// mp-algorithms/functional-solver.h
//
// Copyright (C) 2004-2016 Ian McCulloch <ianmcc@physics.uq.edu.au>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Reseach publications making use of this software should include
// appropriate citations and acknowledgements as described in
// the file CITATIONS in the main source directory.
//----------------------------------------------------------------------------
// ENDHEADER

#if !defined(FUNCTIONAL_MINIMIZE_H_HHVERTHYEHYYOIUDLE89P)
#define FUNCTIONAL_MINIMIZE_H_HHVERTHYEHYYOIUDLE89P

#include "matrixproduct/splitoperator.h"
#include "matrixproduct/centerwavefunction.h"
#include "matrixproduct/operatorstack.h"
#include "common/math_const.h"

// Finds the wavefunction x that minimizes the functional
// F = <x|A|x> + <y|B|x> + <x|B^\dagger|y>
// using a Krylov subspace generated by some operator H

struct FunctionalSolver
{
   typedef OperatorStack<MPStateComponent> SuperblockOperator;
   typedef OperatorStack<MatrixOperator>   TransformOperator;

   FunctionalSolver(CenterWavefunction const& Psi_, SplitOperator const& A_,
                    SplitOperator const& B_, SplitOperator const& H_, SplitOperator const& Hb_,
                    CenterWavefunction const& Rhs_, double Freq_, double Broad_);

   virtual ~FunctionalSolver();

   CenterWavefunction const& Wavefunction() const { return x; }

   int LeftSize() const { return x.LeftSize(); }
   int RightSize() const { return x.RightSize(); }

   // Calculates the wavefunction, using Iterations number
   // Krylvo steps.   Returns the value of the functional.
   double Solve(int Iterations);

   // Does a truncation and shifts the Center matrix to the right.
   // The new left basis is automatically expanded.
   void ShiftRightAndExpand();

   // Does a truncation and shifts the Center matrix to the left.
   // The new right basis is automatically expanded.
   void ShiftLeftAndExpand();

   // 'Expands' the left basis to cover all states.
   void ExpandLeft();

   // 'Expands' the right basis to cover all states.
   void ExpandRight();

   // returns the overlap < y | A | x >
   //   virtual std::complex<double> Overlap() const = 0;

   TruncationInfo TruncateLeft(StatesInfo const& SInfo, double CFactor);
   TruncationInfo TruncateRight(StatesInfo const& SInfo, double CFactor);

   // debug sanity check that the wavefunction and operator basis agree
   void DebugCheckBasis() const;

   CenterWavefunction x;             // the left hand side that we are solving for
   SplitOperator A, B, H, Hb;
   CenterWavefunction y;             // the fixed right hand side

   SuperblockOperator x_A_x;    // matrix elements   | x > A < x |
   SuperblockOperator x_H_x;    // matrix elements   | x > H < x |
   SuperblockOperator x_Hb_x;    // matrix elements   | x > \bar{H} < x |
   SuperblockOperator x_B_y;    // matrix elements   | x > B < y |
   TransformOperator x_y;       // matrix elements   | x > < y |

   double Frequency;
   double Broadening;

   QuantumNumber Ident;

   double Precision;  // precision for the solver - stop if change in iteration is less
   int MinIterations; // minimum number of krylov iterations to perform
   bool TwoStepKrylov; // if true, add Krylov vectors as H|k_n> and H^2|k_{n-1}> alternately
   bool MixNormalize;  // if true, normalize DM for x and y before constructing the mixture
   double LanczosMixFactor; // Mixing factor for |y> in the density matrix for |x>
   bool LinearSolver; // if true, solve the linear equations H\x> = |y>, instead of the functional minimum
   bool SquareMeHarder; // if true, apply H*Hb to get H^2
   bool UseResid;      // make use of the best approximation residual vector when constructing the Krylov basis

   // per-iteration statistics
   int IterationNumMultiplies;
};

#endif
