//----------------------------------------------------------------------------
// Matrix Product Toolkit http://physics.uq.edu.au/people/ianmcc/mptoolkit/
//
// cuda/cuda.ipp
//
// Copyright (C) 2017 Ian McCulloch <ianmcc@physics.uq.edu.au>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Reseach publications making use of this software should include
// appropriate citations and acknowledgements as described in
// the file CITATIONS in the main source directory.
//----------------------------------------------------------------------------
// ENDHEADER

namespace cuda
{

namespace detail
{

cudaStream_t AllocateStream();
void FreeStream(cudaStream_t e);

cudaEvent_t AllocateEvent();
void FreeEvent(cudaEvent_t e);

} // namespace detail

//
// device
//

inline
int num_devices()
{
   int Result;
   cudaError_t e = cudaGetDeviceCount(&Result);
   if (e == cudaSuccess)
      return Result;
   if (e == cudaErrorNoDevice)
      return 0;
   if (e == cudaErrorInsufficientDriver)
      return 0;
   throw error(e);
}

inline
void set_device(int d)
{
   check_error(cudaSetDevice(d));
}

inline
int get_device()
{
   int Result;
   check_error(cudaGetDevice(&Result));
   return Result;
}

inline
device_properties get_device_properties(int d)
{
   device_properties Result;
   check_error(cudaGetDeviceProperties(&Result.p_, d));
   return Result;
}

inline
void device_synchronize()
{
   check_error(cudaDeviceSynchronize());
}

//
// stream
//

inline
stream::stream() : stream_(detail::AllocateStream())
{
   count_.allocate(1);
}

inline
stream::stream(stream&& other) : stream_(other.stream_), count_(std::move(other.count_))
{
   other.stream_ = nullptr;
}

inline
stream&
stream::operator=(stream&& other)
{
   std::swap(stream_, other.stream_);
   std::swap(count_, other.count_);
   return *this;
}

inline
stream::stream(stream const& other) : stream_(other.stream_), count_(other.count_)
{
   if (stream_)
      ++count_;
}

inline
stream&
stream::operator=(stream const& other)
{
   if (other.stream_)
      ++other.count_;

   this->sub_reference();
   stream_ = other.stream_;
   count_ = other.count_;

   return *this;
}

inline
stream::~stream()
{
   this->sub_reference();
}

inline
void
stream::safe_to_destroy()
{
   if (stream_ && !count_.is_shared())
   {
      // we are the only reference to the stream, we can kill it
      stream_ = nullptr;
      count_.deallocate();
   }
}


inline
void
stream::sub_reference()
{
   if (stream_ && (--count_ == 0))
   {
      if (this->is_running())
      {
         PANIC("Possible bug: destroying stream that has pending operations");
      }
      detail::FreeStream(stream_);
      // NOTE: we do not set stream_ = nullltr here, caller must do this if necessary
      count_.deallocate();
   }
}

inline
void
stream::wait(event const& e) const
{
   check_error(cudaStreamWaitEvent(stream_, e.raw_event(), 0));
}

inline
event
stream::record()
{
   return event(stream_);
}

inline
void
stream::synchronize()
{
   check_error(cudaStreamSynchronize(stream_));
}

inline
bool
stream::is_running() const
{
   cudaError_t e = cudaStreamQuery(stream_);
   if (e == cudaErrorNotReady)
      return true;
   if (e == cudaSuccess)
      return false;
   // This function ends up getting called when a stream is destroyed on program termination,
   // and the cuda device has already been unloaded.
   if (e == cudaErrorCudartUnloading)
      return false;
   throw error(e);
}

//
// event
//

inline
event::event()
{
}

inline
event::event(cudaStream_t s)
   : event_(new cudaEvent_t(detail::AllocateEvent()))
{
   check_error(cudaEventRecord(*event_, s));
   count_.allocate(1);
}

inline
event::event(event&& other) : event_(std::move(other.event_)), count_(std::move(other.count_))
{
}

inline
event::event(event const& other) : event_(new cudaEvent_t(*other.event_)), count_(other.count_)
{
   if (event_ && *event_)
      ++count_;
}

inline
event&
event::operator=(event&& other)
{
   event_ = std::move(other.event_);
   count_ = std::move(other.count_);
   return *this;
}

inline
event&
event::operator=(event const& other)
{
   if (other.event_ && *other.event_)
      ++other.count_;

   if (event_)
      this->sub_reference();
   if (other.event_)
      event_.reset(new cudaEvent_t(*other.event_));
   else
      event_.reset();
   count_ = other.count_;
   return *this;
}

inline
event::~event()
{
   if (event_)
      this->sub_reference();
 }

inline
void
event::clear()
{
   if (event_)
      this->sub_reference();
   event_.reset();
   count_.reset();
}

inline
void
event::wait() const
{
   CHECK(event_);
   check_error(cudaEventSynchronize(*event_));
}

inline
void
event::sub_reference()
 {
   if (*event_ && (--count_ == 0))
   {
      detail::FreeEvent(*event_);
      // NOTE: we do not set event_ = nullltr here, caller must do this if necessary
      count_.deallocate();
   }
}

inline
bool
event::is_complete() const
{
   cudaError_t e = cudaEventQuery(*event_);
   if (e == cudaSuccess)
      return true;
   if (e == cudaErrorNotReady)
      return false;
   throw error(e);
}

inline
bool
event_ref::is_complete() const
{
   cudaError_t e = cudaEventQuery(*event_);
   if (e == cudaSuccess)
      return true;
   if (e == cudaErrorNotReady)
      return false;
   throw error(e);
}


//
// timer
//

inline
timer::timer() : start_(Allocate()), stop_(Allocate())
{
}

inline
timer::timer(timer&& other) : start_(other.start_), stop_(other.stop_)
{
   other.start_ = nullptr;
   other.stop_ = nullptr;
}

inline
timer&
timer::operator=(timer&& other)
{
   using std::swap;
   swap(start_, other.start_);
   swap(stop_, other.stop_);
   return *this;
}

inline
timer::~timer()
{
   if (start_ || stop_)
   {
      std::lock_guard<std::mutex> lock(timer::FreeListMutex);
      if (start_)
      {
	 timer::FreeList.push_back(start_);
	 start_ = nullptr;
      }
      if (stop_)
      {
	 timer::FreeList.push_back(stop_);
	 stop_ = nullptr;
      }
   }
}

inline
cudaEvent_t
timer::Allocate()
{
   std::lock_guard<std::mutex> lock(timer::FreeListMutex);
   if (FreeList.empty())
   {
      for (int i = 0; i < 10; ++i)
      {
	 cudaEvent_t s;
	 check_error(cudaEventCreateWithFlags(&s, cudaEventDefault));
	 FreeList.push_back(s);
      }
   }
   cudaEvent_t s = FreeList.back();
   FreeList.pop_back();
   return s;
}

inline
float
timer::elapsed_time_ms() const
{
   float Result;
   cudaError_t e = cudaEventElapsedTime(&Result, start_, stop_);
   if (e == cudaSuccess)
      return Result;
   throw error(e);
}

inline
bool
timer::is_started() const
{
   cudaError_t e = cudaEventQuery(start_);
   if (e == cudaSuccess)
      return true;
   if (e == cudaErrorNotReady)
      return false;
   throw error(e);
}

inline
bool
timer::is_complete() const
{
   if (!this->is_started())
      return false;
   cudaError_t e = cudaEventQuery(stop_);
   if (e == cudaSuccess)
      return true;
   if (e == cudaErrorNotReady)
      return false;
   throw error(e);
}

} // namespace cuda
