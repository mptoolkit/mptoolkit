// -*- C++ -*-
//----------------------------------------------------------------------------
// Matrix Product Toolkit http://physics.uq.edu.au/people/ianmcc/mptoolkit/
//
// tensor/tensor.icc
//
// Copyright (C) 2004-2016 Ian McCulloch <ianmcc@physics.uq.edu.au>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Reseach publications making use of this software should include
// appropriate citations and acknowledgements as described in
// the file CITATIONS in the main source directory.
//----------------------------------------------------------------------------
// ENDHEADER

#include "tensor_types.h"

namespace Tensor
{

//
// IrredTensor
//

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>::IrredTensor(basis1_type const& Basis)
   : Basis1_(Basis), Basis2_(Basis), Trans_(Basis.GetSymmetryList()), Data_(Basis.size(), Basis.size())
{
   DEBUG_CHECK_EQUAL(Basis.GetSymmetryList(), Trans_.GetSymmetryList());
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>::IrredTensor(basis1_type const& Basis, QuantumNumber const& Trans)
   : Basis1_(Basis), Basis2_(Basis), Trans_(Trans), Data_(Basis.size(), Basis.size())
{
   DEBUG_CHECK_EQUAL(Basis.GetSymmetryList(), Trans.GetSymmetryList());
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>::IrredTensor(basis1_type const& Basis1, basis2_type const& Basis2,
				       QuantumNumber const& Trans)
   : Basis1_(Basis1), Basis2_(Basis2), Trans_(Trans), Data_(Basis1.size(), Basis2.size())
{
   DEBUG_CHECK_EQUAL(Basis1.GetSymmetryList(), Basis2.GetSymmetryList());
   DEBUG_CHECK_EQUAL(Basis1.GetSymmetryList(), Trans.GetSymmetryList());
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>::IrredTensor(basis1_type const& Basis1, basis2_type const& Basis2)
   : Basis1_(Basis1), Basis2_(Basis2), Trans_(Basis1.GetSymmetryList()),
     Data_(Basis1.size(), Basis2.size())
{
   DEBUG_CHECK_EQUAL(Basis1.GetSymmetryList(), Basis2.GetSymmetryList());
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>::IrredTensor(basis1_type const& Basis1, basis2_type const& Basis2,
				       QuantumNumber const& Trans, StructureType&& Data)
   : Basis1_(Basis1), Basis2_(Basis2), Trans_(Trans), Data_(std::move(Data))
{
   DEBUG_CHECK_EQUAL(Basis1.GetSymmetryList(), Basis2.GetSymmetryList());
   DEBUG_CHECK_EQUAL(Basis1.GetSymmetryList(), Trans.GetSymmetryList());
   DEBUG_CHECK_EQUAL(Data_.rows(), Basis1.size());
   DEBUG_CHECK_EQUAL(Data_.cols(), Basis2.size());
}


template <typename T, typename B1, typename B2, typename S>
void implement_check_structure(IrredTensor<T, B1, B2, S> const& x)
{
   for (auto const& rx : x)
   {
      for (auto const& cx : rx)
      {
         CHECK(is_transform_target(x.qn2(cx.col()),
                                   x.TransformsAs(),
                                   x.qn1(rx.row())))
            (x.qn2(cx.col()))(x.TransformsAs())(x.qn1(rx.row()));
      }
   }
}

template <typename T, typename S>
void implement_check_structure(IrredTensor<T, VectorBasis, VectorBasis, S> const& x)
{
   for (auto const& rx : x)
   {
      for (auto const& cx : rx)
      {
         CHECK(is_transform_target(x.qn2(cx.col()),
                                   x.TransformsAs(),
                                   x.qn1(rx.row())))
            (x.qn2(cx.col()))(x.TransformsAs())(x.qn1(rx.row()))(x);
         CHECK_EQUAL(cx.value.rows(), x.Basis1().dim(rx.row()))(rx.row())(cx.col())(x)(cx.value);
         CHECK_EQUAL(cx.value.cols(), x.Basis2().dim(cx.col()))(rx.row())(cx.col())(x)(cx.value);
      }
   }
}

template <typename T, typename B1, typename B2, typename S>
void IrredTensor<T, B1, B2, S>::check_structure() const
{
   implement_check_structure(*this);
}

template <typename T, typename B1, typename B2, typename S>
void
IrredTensor<T, B1, B2, S>::CoerceSymmetryList(SymmetryList const& sl)
{
   using Tensor::CoerceSymmetryList;
   Basis1_.CoerceSymmetryList(sl);
   Basis2_.CoerceSymmetryList(sl);
   Trans_.CoerceSymmetryList(sl);
   Data_ = CoerceSymmetryList(std::move(Data_), sl);
   this->debug_check_structure();
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>
CoerceSymmetryList(IrredTensor<T, B1, B2, S> const& t, SymmetryList const& sl)
{
   IrredTensor<T, B1, B2, S> Result;
   Result.Basis1_ = CoerceSymmetryList(t.Basis1_, sl);
   Result.Basis2_ = CoerceSymmetryList(t.Basis2_, sl);
   Result.Trans_ = CoerceSymmetryList(t.Trans_, sl);
   Result.Data_ = CoerceSymmetryList(t.Data_, sl);
   Result.debug_check_structure();
   return Result;
}

template <typename T, typename B1, typename B2, typename S>
void
CoerceSymmetryListInPlace(IrredTensor<T, B1, B2, S>& t, SymmetryList const& sl)
{
   t.CoerceSymmetryList(sl);
}

template <typename T, typename B1, typename B2, typename S>
inline
void IrredTensor<T, B1, B2, S>::debug_check_structure() const
{
#if !defined(NDEBUG)
   this->check_structure();
#endif
}

template <typename T, typename B1, typename B2, typename S>
PStream::opstream& operator<<(PStream::opstream& out, IrredTensor<T, B1, B2, S> const& Op)
{
   return out << Op.Basis1_ << Op.Basis2_ << Op.Trans_ << Op.Data_;
}

template <typename T, typename B1, typename B2, typename S>
PStream::ipstream& operator>>(PStream::ipstream& in, IrredTensor<T, B1, B2, S>& Op)
{
   return in >> Op.Basis1_ >> Op.Basis2_ >> Op.Trans_ >> Op.Data_;
}

template <typename T, typename B1, typename B2, typename S>
std::ostream& operator<<(std::ostream& out, IrredTensor<T, B1, B2, S> const& Op)
{
   out << "Operator transforms with symmetry " << Op.GetSymmetryList()
       << " as " << Op.TransformsAs() << ":\nBasis1: " << Op.Basis1()
       << "\nBasis2: " << Op.Basis2() << "\n"
       << Op.data();
   return out;
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>&
IrredTensor<T, B1, B2, S>::operator+=(IrredTensor const& Op)
{
#if 0
   // quick return if the right hand side is zero
   if (Op.is_null()) return *this;

   if (this->is_null())
   {
      *this = Op;
      return *this;
   }
#endif

   PRECONDITION(Basis1_ == Op.Basis1_)(Basis1_)(Op.Basis1_);
   PRECONDITION(Basis2_ == Op.Basis2_)(Basis2_)(Op.Basis2_);
   PRECONDITION(Trans_ == Op.Trans_)(Trans_)(Op.Trans_);
   Data_ += Op.Data_;

   this->debug_check_structure();
   return *this;
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>&
IrredTensor<T, B1, B2, S>::operator+=(IrredTensor&& Op)
{
   // quick return if the right hand side is zero
   if (Op.is_null()) return *this;

   if (this->is_null())
   {
      *this = std::move(Op);
      return *this;
   }

   PRECONDITION(Basis1_ == Op.Basis1_)(Basis1_)(Op.Basis1_);
   PRECONDITION(Basis2_ == Op.Basis2_)(Basis2_)(Op.Basis2_);
   PRECONDITION(Trans_ == Op.Trans_)(Trans_)(Op.Trans_);

   Data_ += std::move(Op.Data_);

   this->debug_check_structure();
   return *this;
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>&
IrredTensor<T, B1, B2, S>::operator-=(IrredTensor const& Op)
{
#if 0
   // quick return if the right hand side is zero
   if (Op.is_null()) return *this;

   if (this->is_null())
   {
      *this = -Op;
      return *this;
   }
#endif

   PRECONDITION(Basis1_ == Op.Basis1_)(Basis1_)(Op.Basis1_);
   PRECONDITION(Basis2_ == Op.Basis2_)(Basis2_)(Op.Basis2_);
   PRECONDITION(Trans_ == Op.Trans_)(Trans_)(Op.Trans_);
   Data_ -= Op.Data_;

   this->debug_check_structure();
   return *this;
}

template <typename T, typename B1, typename B2, typename S>
IrredTensor<T, B1, B2, S>&
IrredTensor<T, B1, B2, S>::operator-=(IrredTensor&& Op)
{
#if 0
   // quick return if the right hand side is zero
   if (Op.is_null()) return *this;

   if (this->is_null())
   {
      *this = -Op;
      return *this;
   }
#endif

   PRECONDITION(Basis1_ == Op.Basis1_)(Basis1_)(Op.Basis1_);
   PRECONDITION(Basis2_ == Op.Basis2_)(Basis2_)(Op.Basis2_);
   PRECONDITION(Trans_ == Op.Trans_)(Trans_)(Op.Trans_);
   Data_ -= std::move(Op.Data_);

   this->debug_check_structure();
   return *this;
}

//
// triple_prod
//

// add_triple_prod

template <typename U, typename T1, typename B1, typename B2, typename S1,
          typename T2, typename B3, typename S2,
          typename T3, typename B4, typename S3, typename T4, typename S4>
void
add_triple_prod(U Factor,
                HermitianProxy<Tensor::IrredTensor<T1, B1, B2, S1> > const& x,
                Tensor::IrredTensor<T2, B1, B3, S2> const& E,
                Tensor::IrredTensor<T3, B3, B4, S3> const& y,
                QuantumNumber qxy, Tensor::IrredTensor<T4, B1, B4, S4>& Result)
{
#if 0
   if (x.base().is_null() || y.is_null() || E.is_null())
      return;
#endif

   QuantumNumber qEp = Result.TransformsAs();
   DEBUG_PRECONDITION_EQUAL(y.GetSymmetryList(), x.base().GetSymmetryList());
   DEBUG_PRECONDITION_EQUAL(y.GetSymmetryList(), qxy.GetSymmetryList());
   DEBUG_PRECONDITION_EQUAL(y.GetSymmetryList(), E.GetSymmetryList());
   DEBUG_PRECONDITION_EQUAL(y.GetSymmetryList(), qEp.GetSymmetryList());
   QuantumNumber Transx = x.base().TransformsAs();
   QuantumNumber Transy = y.TransformsAs();
   QuantumNumber TransE = E.TransformsAs();
   PRECONDITION(is_transform_target(Transy, qxy, Transx))(Transy)(qxy)(Transx);
   PRECONDITION(is_transform_target(qEp, qxy, TransE))(qEp)(qxy)(TransE);
   DEBUG_PRECONDITION_EQUAL(x.base().Basis1(), E.Basis1());
   DEBUG_PRECONDITION_EQUAL(E.Basis2(), y.Basis1());
   DEBUG_PRECONDITION_EQUAL(Result.Basis1(), x.base().Basis2());
   DEBUG_PRECONDITION_EQUAL(Result.Basis2(), y.Basis2());

   IrredTensor<T1, B1, B2, S1> const& xb = x.base();  // shortcut

   // iterate over elements in E first
   for (auto const& Ei : E)
   {
      //      auto& xi = xb.row(Ei.row());

      QuantumNumber qEi = E.qn1(Ei.row());
      double DegEi = qdim(qEi);
      for (auto const& Ein : Ei)
      {
         QuantumNumber qEj = E.qn2(Ein.col());
         for (auto const& xin : xb.row(Ei.row()))
         {
            QuantumNumber qxip = xb.qn2(xin.col());
            double DegXi = qdim(qxip);
            for (auto const& yin : y.row(Ein.col()))
            {
               QuantumNumber qyj = y.Basis2()[yin.col()];
               if (!(is_transform_target(qyj, qEp, qxip))) continue;

               double Coefficient = (DegEi / DegXi) *
                  tensor_coefficient(qyj, Transy, qEj,
                                     qEp, qxy, TransE,
                                     qxip, Transx, qEi);

               if (fabs(Coefficient) > 1E-10)
               {
                  Matrix Temp = Ein.value * yin.value;
                  Result.add(xin.col(), yin.col(), (Factor*Coefficient) * herm(xin.value) * Temp);
               }
            }
         }
      }
   }
   Result.debug_check_structure();
}

template <typename T, typename B1, typename B2, typename S1,
          typename B3, typename S2,
          typename B4, typename S3>
IrredTensor<T, B2, B4>
triple_prod(HermitianProxy<IrredTensor<T, B1, B2, S1> > const& x,
            IrredTensor<T, B1, B3, S2> const& E,
            IrredTensor<T, B3, B4, S3> const& y,
            QuantumNumber qxy,
            QuantumNumber qEp)
{
   IrredTensor<T, B2, B4> Result(x.base().Basis2(), y.Basis2(), qEp);
   add_triple_prod(1.0, x, E, y, qxy, Result);
   return Result;
}

template <typename T, typename B1, typename B2, typename S1,
          typename B3, typename S2,
          typename B4, typename S3>
inline
IrredTensor<T, B2, B4>
triple_prod(HermitianProxy<IrredTensor<T, B1, B2, S1> > const& x,
            IrredTensor<T, B1, B3, S2> const& E,
            IrredTensor<T, B3, B4, S3> const& y)
{
   return triple_prod(x, E, y, QuantumNumber(y.GetSymmetryList()), E.TransformsAs());
}

template <typename U, typename T, typename B1, typename B2, typename S1,
          typename B3, typename S2,
          typename B4, typename S3, typename T4, typename S4>
inline
void
add_triple_prod(U Factor, HermitianProxy<Tensor::IrredTensor<T, B1, B2, S1> > const& x,
                Tensor::IrredTensor<T, B1, B3, S2> const& E,
                Tensor::IrredTensor<T, B3, B4, S3> const& y,
                Tensor::IrredTensor<T, B1, B4, S4>& Result)
{
   add_triple_prod(Factor, x, E, y, QuantumNumber(y.GetSymmetryList()), Result);
}



template <typename U, typename T1, typename B1, typename B2, typename S1,
          typename T2, typename B3, typename S2,
          typename T3, typename B4, typename S3, typename T4, typename S4>
void
add_triple_prod(U Factor,
                Tensor::IrredTensor<T1, B1, B2, S1> const& x,
                Tensor::IrredTensor<T2, B2, B3, S2> const& E,
                HermitianProxy<Tensor::IrredTensor<T3, B4, B3, S3> > const& y,
                QuantumNumber qxy, Tensor::IrredTensor<T4, B1, B4, S4>& Result)
{
   QuantumNumber qEp = Result.TransformsAs();
   DEBUG_PRECONDITION_EQUAL(x.GetSymmetryList(), y.base().GetSymmetryList());
   DEBUG_PRECONDITION_EQUAL(x.GetSymmetryList(), qxy.GetSymmetryList());
   DEBUG_PRECONDITION_EQUAL(x.GetSymmetryList(), E.GetSymmetryList());
   DEBUG_PRECONDITION_EQUAL(x.GetSymmetryList(), qEp.GetSymmetryList());
   QuantumNumber Transx = x.TransformsAs();
   QuantumNumber Transy = y.base().TransformsAs();
   QuantumNumber TransE = E.TransformsAs();
   DEBUG_PRECONDITION(is_transform_target(Transy, qxy, Transx))(Transy)(qxy)(Transx);
   DEBUG_PRECONDITION(is_transform_target(TransE, qxy, qEp))(TransE)(qxy)(qEp);
   DEBUG_PRECONDITION_EQUAL(x.Basis2(), E.Basis1());
   DEBUG_PRECONDITION_EQUAL(E.Basis2(), y.base().Basis2());
   DEBUG_PRECONDITION_EQUAL(Result.Basis1(), x.Basis1());
   DEBUG_PRECONDITION_EQUAL(Result.Basis2(), y.base().Basis1());

   IrredTensor<T3, B4, B3, S3> const& yb = y.base();  // shortcut

   for (auto const& xi : x)
   {
      QuantumNumber qxp = x.qn1(xi.row());
      for (auto const& yi : yb)
      {
         QuantumNumber qyp = yb.qn1(yi.row());
         if (!is_transform_target(qyp, qEp, qxp)) continue;

         for (auto const& xin : xi)
         {
            for (auto const& yin : yi)
            {
               auto const& EIn = E.row(xin.col()).find(yin.col());
               if (EIn != E.row(xin.col()).end())
               {
                  /*
                  double Coefficient = tensor_coefficient(x.Basis2()[xin.index2()], Transx, qxp,
                                                          TransE, qxy, qEp,
                                                          yb.Basis2()[yin.index2()], Transy, qyp);
                  */
                  double Coefficient = tensor_coefficient(yb.qn2(yin.col()), Transy, qyp,
                                                          TransE, qxy, qEp,
                                                          x.qn2(xin.col()), Transx, qxp);

                  if (fabs(Coefficient) > 1E-10)
                  {
                     Matrix Temp = EIn.value() * herm(yin.value);
                     Result.add(xin.col(), yin.col(), (Factor * Coefficient) * xin.value * Temp);
                  }
               }
            }
         }
      }
   }

   Result.debug_check_structure();
}

template <typename T, typename B1, typename B2, typename S1,
          typename B3, typename S2, typename B4>
Tensor::IrredTensor<T, B1, B4, S1>
triple_prod(Tensor::IrredTensor<T, B1, B2, S1> const& x,
            Tensor::IrredTensor<T, B2, B3, S2> const& E,
            HermitianProxy<Tensor::IrredTensor<T, B4, B3, S1> > const& y,
            QuantumNumber qxy, QuantumNumber qEp)
{

   Tensor::IrredTensor<T, B1, B4, S1> Result(x.Basis1(), y.base().Basis1(), qEp);
   add_triple_prod(1.0, x, E, y, qxy, Result);
   return Result;
}


template <typename T, typename B1, typename B2, typename S1,
          typename B3, typename S2,
          typename B4, typename S3>
inline
IrredTensor<T, B1, B4>
triple_prod(IrredTensor<T, B1, B2, S1> const& x,
            IrredTensor<T, B2, B3, S2> const& E,
            HermitianProxy<IrredTensor<T, B4, B3, S3> > const& y)
{
   return triple_prod(x, E, y, QuantumNumber(x.GetSymmetryList()), E.TransformsAs());
}

template <typename U, typename T, typename B1, typename B2, typename S1,
          typename B3, typename S2,
          typename B4, typename S3, typename T4, typename S4>
inline
void
add_triple_prod(U Factor,
                Tensor::IrredTensor<T, B1, B2, S1> const& x,
                Tensor::IrredTensor<T, B2, B3, S2> const& E,
                HermitianProxy<Tensor::IrredTensor<T, B4, B3, S3> > const& y,
                Tensor::IrredTensor<T, B1, B4, S4>& Result)
{
   add_triple_prod(Result, Factor, x, E, y, QuantumNumber(x.GetSymmetryList()), Result);
}

//
// A * herm(B)
// B must be a scalar type
//

template <typename T, typename B1, typename B2, typename B3,
	  typename S>
IrredTensor<T, B1, B3, S>
operator*(IrredTensor<T, B1, B2, S> const& x, HermitianProxy<IrredTensor<T, B3, B2, S>> const& y)
{
   DEBUG_PRECONDITION_EQUAL(x.Basis2(), y.base().Basis2());
   DEBUG_CHECK(is_scalar(y.base().TransformsAs()));

   IrredTensor<T, B1, B3, S> Result(x.Basis1(), y.base().Basis1(), x.TransformsAs());
   QuantumNumber Trans = x.TransformsAs();
   QuantumNumber Ident(x.GetSymmetryList());

   for (auto const& xi : x)
   {
      QuantumNumber qp = x.Basis1()[xi.row()];
      for (auto const& xj : xi)
      {
         QuantumNumber qpp = x.Basis2()[xj.col()];

	 for (auto const& yi : y.base())
	 {
	    for (auto const& yj : yi)
	    {
               if (yj.col() != xj.col())
                  continue;

               // because y is a scalar, q == qpp always
               // QuantumNumber q = y.Basis2()[yin.index2()];

               // There is no extra coefficient from the transpose of a scalar operator
               double Coefficient = product_coefficient(Trans, Ident, Trans,
                                                     qp, qpp, qpp);
               if (fabs(Coefficient) > 1E-10)
               {
		  Result.add(xi.row(), yi.row(), Coefficient * xj.value * herm(yj.value));
               }
            }
         }
      }
   }
   Result.debug_check_structure();
   return Result;
}

template <typename T, typename B1, typename B2, typename B3,
	  typename S>
IrredTensor<T, B1, B3, S>
operator*(HermitianProxy<IrredTensor<T, B2, B1, S>> const& x, IrredTensor<T, B2, B3, S> const& y)
{
   DEBUG_PRECONDITION_EQUAL(x.base().Basis1(), y.Basis1());
   DEBUG_PRECONDITION(is_scalar(x.base().TransformsAs()));

   IrredTensor<T, B1, B3, S> Result(x.base().Basis2(), y.Basis2(), y.TransformsAs());
   QuantumNumber Trans = y.TransformsAs();
   QuantumNumber Ident(y.GetSymmetryList());

   for (int i = 0; i < y.Basis1().size(); ++i)
   {
      QuantumNumber qpp = y.Basis1()[i];
      for (auto const& xj : x.base().data().row(i))
      {
         // because x is a scalar, qp == qpp always
         // QuantumNumber qp = x.base().Basis2()[xin.index2()];
	 for (auto const& yj : y.data().row(i))
	 {
            QuantumNumber q = y.Basis2()[yj.col()];

            //if (!(is_transform_target(q, Result.TransformsAs(), qpp))) continue;

            // There is no extra coefficient from the transpose of a scalar operator
            double Coefficient = product_coefficient(Ident, Trans, Trans,
                                                     qpp, q, qpp);
            if (fabs(Coefficient) > 1E-10)
            {
	       Result.add(xj.col(), xj.col(), Coefficient * herm(xj.value) * yj.value);
            }
         }
      }
   }
   Result.debug_check_structure();
   return Result;
}

//
// delta_shift
//

template <typename T, typename B1, typename B2, typename S>
void
Tensor::IrredTensor<T, B1, B2, S>::delta_shift(QuantumNumbers::QuantumNumber const& q)
{
   Basis1_.delta_shift(q);
   Basis2_.delta_shift(q);
}

template <typename T, typename B1, typename B2, typename S>
Tensor::IrredTensor<T, B1, B2, S>
delta_shift(Tensor::IrredTensor<T, B1, B2, S> const& x,
            QuantumNumbers::QuantumNumber q,
            QuantumNumbers::Projection p,
            B1 const& NewBasis1, B2 const& NewBasis2)
{
   if (x.is_null())
   {
      DEBUG_TRACE("delta_shift: null tensor");
      return Tensor::IrredTensor<T, B1, B2, S>();
   }

   DEBUG_CHECK_EQUAL(NewBasis1, delta_shift(x.Basis1(), p));
   DEBUG_CHECK_EQUAL(NewBasis2, delta_shift(x.Basis2(), p));

   QuantumNumber Ident(x.GetSymmetryList());

   IrredTensor<T, B1, B2, S> Result(NewBasis1, NewBasis2, x.TransformsAs());

   Result.data() = copy(x.data());

#if 0
   typedef typename IrredTensor<T, B1, B2, S>::const_iterator       const_iterator;
   typedef typename IrredTensor<T, B1, B2, S>::const_inner_iterator const_inner_iterator;

   // This was a misguided attempt for non-abelian shifts (which dont actually exist)
   for (const_iterator I = iterate(x); I; ++I)
   {
      for (const_inner_iterator J = iterate(I); J; ++J)
      {
         // The scale factor here depends on the normalization of the coupling
         // coefficients.

         //double Scale = std::sqrt(double(degree(x.qn1(J.index1())))
         // degree(NewBasis1[J.index1()]));
                 //double Scale = 1.0;
         double Scale = delta_shift_coefficient(x.qn1(J.index1()), x.TransformsAs(),
                                                x.qn2(J.index2()), q);

         Result(J.index1(), J.index2()) = Scale * (*J);
      }
   }
#endif
   return Result;
}

template <typename T, typename B1, typename B2, typename S>
Tensor::IrredTensor<T, B1, B2, S>
delta_shift(Tensor::IrredTensor<T, B1, B2, S> const& x,
            QuantumNumbers::QuantumNumber q,
            QuantumNumbers::Projection p)
{
   return delta_shift(x, q, p, delta_shift(x.Basis1(), p), delta_shift(x.Basis2(), p));
}

template <typename T, typename B1, typename B2, typename S>
Tensor::IrredTensor<T, B1, B2, S>
delta_shift(Tensor::IrredTensor<T, B1, B2, S> const& x,
            QuantumNumbers::QuantumNumber q)
{
   QuantumNumbers::ProjectionList PL = enumerate_projections(q);
   DEBUG_PRECONDITION_EQUAL(q.degree(), 1);

   return delta_shift(x, q, PL[0], delta_shift(x.Basis1(), PL[0]), delta_shift(x.Basis2(), PL[0]));
}

// trace
template <typename T, typename B, typename S>
std::enable_if_t<!blas::is_numeric_v<T>, blas::remove_proxy_t<decltype(trace(std::declval<T>()))>>
trace(IrredTensor<T, B, B, S> const& x)
{
   using blas::trace;
   CHECK_EQUAL(x.Basis1(), x.Basis2());
   using numeric_type = blas::remove_proxy_t<decltype(trace(std::declval<T>()))>;
   blas::Vector<numeric_type, typename T::tag_type> Results(x.size1(), 0.0);
   for (auto const& r : x)
   {
      auto I = r.find(r.row());
      if (I != r.end())
      {
	 trace(I.value(), Results[r.row()]);
      }
   }
   return get_wait(sum(Results));
}

template <typename T, typename B, typename S>
std::enable_if_t<blas::is_numeric_v<T>, T>
trace(IrredTensor<T, B, B, S> const& x)
{
   using blas::trace;
   CHECK_EQUAL(x.Basis1(), x.Basis2());
   T Result{};
   for (auto const& r : x)
   {
      auto I = r.find(r.row());
      if (I != r.end())
      {
	 Result += trace(I.value());
      }
   }
   return Result;
}


} // namespace Tensor
