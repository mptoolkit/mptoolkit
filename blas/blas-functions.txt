
Here, Matrix is used as a place-holder for a concrete matrix type,
Vector is used as a place-holder for a concrete vector type.
alpha, beta are scalars of the same value_type as the corresponding
Matrix/Vector.

Typically implementations will have one more layer of wrappers
between these functions and the low-level BLAS library.


// middle-layer expression templates.  These are rewritten to use the appropriate BLAS-like functions.
// Concrete class assignment operators should forward directly to these.
// assign(A&, B)
// add(A&, B)
// subtract(A&, B)
// evaluate(A&&) // evaluates the expression and returns a concrete value (can be used for type deduction)


Middle-level BLAS-like functions:

// get the library name for the low-level blas library
char const* <type>_blas_library()

// y = x
vector_copy(BlasVector x, BlasVector& y)

y = alpha * x
vector_copy_scaled(alpha, BlasVector x, BlasVector& y)

// y += x
vector_add(BlasVector x, BlasVector& y)

y += alpha * x
vector_add_scaled(alpha, BlasVector x, BlasVector& y)

// y = alpha * A * x + beta * y
gemv(alpha, BlasMatrix A, beta, BlasVector x, beta, Vector& y)

// y *= alpha
vector_scale(alpha, Vector& y)

// functions that return scalar values - Ref here stands
// for traits::async_ref<T>

// y = sum x[i]
vector_sum(BlasVector x, Ref& y)

// y = alpha * (sum x[i])
//vector_sum_scaled(alpha, BlasVector x, Ref& y)

// z = sum conj(x[i]) * y[i]
inner_prod(BlasVector x, BlasVector y, Ref& z)

// z += sum conj(x[i]) * y[i]
add_inner_prod(BlasVector x, BlasVector y, Ref& z)

// z = sum x[i] * y[i]
vector_dot(BlasVector x, BlasVector y, Ref& z)

vector_clear(Vector& y)


// y = x, also does transpose etc operations
matrix_copy(BlasMatrix x, Matrix& y)

// y = alpha * x
matrix_copy_scaled(alpha, BlasMatrix x, Matrix& y)

// y += x
matrix_add(BlasMatrix x, Matrix& y)

// y += alpha * x
matrix_add_scaled(alpha, BlasMatrix x, Matrix& y)

// C = alpha * A + beta * B
// If the underlying BLAS library supports in-place operations (ie B == C), eg cuBLAS,
// the the add/copy operations above can be implemented in terms of geam
geam(alpha, BlasMatrix A, beta, BlasMatrix B, Matrix& C)

// C = alpha * a * b + beta * C
gemm(alpha, BlasMatrix A, beta, BlasMatrix B, Matrix& C)

matrix_scale(alpha, Matrix& y)

matrix_clear(Matrix& y)

// z = sum herm(x[i]) ** y[i]
inner_prod(BlasMatrix x, BlasMatrix y, Ref& z)

// z += sum herm(x[i]) ** y[i]
add_inner_prod(BlasMatrix x, BlasMatrix y, Ref& z)


// For conventional CPU storage, the low-level BLAS library implements, for
// T = float/double/complex<float>/complex<double> :

void vector_sum(int N, T const* x, int incx, T& r)

void vector_inner_prod(int N, T const* x, int incx, T const* y, int incy, T& z)



void vector_copy(int N, T const* x, int incx, T* y, int incy)

void vector_add(int N, T const* x, int incx, T* y, int incy)

void vector_add_scaled(int N, T alpha, T const* x, int incx, T* y, int incy)


gemv(char Atrans, int M, int N, int K, T alpha, T const* A, int lda,
     T const* B, int ldb, T beta, T* C, int ldc)


void matrix_copy(char Atrans, int M, int N, T const* A, int lda, T* B, int ldb)

void matrix_copy_scaled(char Atrans, int M, int N, T alpha, T const* A, int lda, T* B, int ldb)

void matrix_add(char Atrans, int M, int N, T const* A, int lda, T* B, int ldb)

void matrix_add_scaled(char Atrans, int M, int N, T alpha, T const* A, int lda, T* B, int ldb)

gemm(char Atrans, char Btrans, int M, int N, int K, T alpha, T const* A, int lda,
     T const* B, int ldb, T beta, T* C, int ldc)

geam(char Atrans, char Btrans, int M, int N, T alpha, T const* A, int lda,
     T beta, T const* B, int ldb,
     T* C, int ldc)

void matrix_inner_prod(char Atrans, char Btrans, int M, int N, T const* A, int lda,  T const* B, int ldb, T& z)

void matrix_add_inner_prod(char Atrans, char Btrans, int M, int N, T const* A, int lda,  T const* B, int ldb, T& z)
